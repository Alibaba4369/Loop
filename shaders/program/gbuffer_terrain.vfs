
/*
!! DO NOT REMOVE !!
This code is from Chocapic13' shaders
Read the terms of modification and sharing before changing something below please !
!! DO NOT REMOVE !!
*/
varying vec2 texcoord;
varying vec4 lmtexcoord;
varying vec4 color;
varying vec4 normalMat;

#ifdef water
varying vec3 binormal;
varying vec3 tangent;					 
varying float dist;
varying vec3 viewVector;
attribute vec4 mc_Entity;
#define SHADOW_MAP_BIAS 0.8
attribute vec4 at_tangent;
uniform mat4 gbufferModelViewInverse;
#else

#ifdef MC_NORMAL_MAP
varying vec4 tangent;
attribute vec4 at_tangent;
#endif
#endif
uniform int blockEntityId;

#ifdef solid1
uniform vec3 cameraPosition;
uniform mat4 gbufferProjectionInverse;
uniform mat4 gbufferModelViewInverse;
uniform float frameTimeCounter;
#endif




uniform vec2 texelSize;
uniform int framemod8;
		const vec2[8] offsets = vec2[8](vec2(1./8.,-3./8.),
									vec2(-1.,3.)/8.,
									vec2(5.0,1.)/8.,
									vec2(-3,-5.)/8.,
									vec2(-5.,5.)/8.,
									vec2(-7.,-1.)/8.,
									vec2(3,7.)/8.,
									vec2(7.,-7.)/8.);






#ifdef solid1								
const float PI48 = 150.796447372;
float pi2wt = PI48*frameTimeCounter*10.;
#endif		
#define diagonal3(m) vec3((m)[0].x, (m)[1].y, m[2].z)
#define  projMAD(m, v) (diagonal3(m) * (v) + (m)[3].xyz)
vec4 toClipSpace3(vec3 viewSpacePosition) {
    return vec4(projMAD(gl_ProjectionMatrix, viewSpacePosition),-viewSpacePosition.z);
}														
								   


#ifdef terrain
vec2 calcWave(in vec3 pos) {

    float magnitude = abs(sin(dot(vec4(frameTimeCounter, pos),vec4(1.0,0.005,0.005,0.005)))*0.5+0.72)*0.013;
	vec2 ret = (sin(pi2wt*vec2(0.0063,0.0015)*4. - pos.xz + pos.y*0.05)+0.1)*magnitude;

    return ret;
}

vec3 calcMovePlants(in vec3 pos) {
    vec2 move1 = calcWave(pos );
	float move1y = -length(move1);
   return vec3(move1.x,move1y,move1.y)*5.*WAVY_STRENGTH;
}

vec3 calcWaveLeaves(in vec3 pos, in float fm, in float mm, in float ma, in float f0, in float f1, in float f2, in float f3, in float f4, in float f5) {

    float magnitude = abs(sin(dot(vec4(frameTimeCounter, pos),vec4(1.0,0.005,0.005,0.005)))*0.5+0.72)*0.013;
	vec3 ret = (sin(pi2wt*vec3(0.0063,0.0224,0.0015)*1.5 - pos))*magnitude;

    return ret;
								 
										
		
													 
														
										   
																					  
}

vec3 calcMoveLeaves(in vec3 pos, in float f0, in float f1, in float f2, in float f3, in float f4, in float f5, in vec3 amp1, in vec3 amp2) {
    vec3 move1 = calcWaveLeaves(pos      , 0.0054, 0.0400, 0.0400, 0.0127, 0.0089, 0.0114, 0.0063, 0.0224, 0.0015) * amp1;
    return move1*5.*WAVY_STRENGTH;
}

#endif																																			
//////////////////////////////VOID MAIN//////////////////////////////
//////////////////////////////VOID MAIN//////////////////////////////
//////////////////////////////VOID MAIN//////////////////////////////
//////////////////////////////VOID MAIN//////////////////////////////
//////////////////////////////VOID MAIN//////////////////////////////

void main() {

											
	vec2 lmcoord = gl_MultiTexCoord1.xy/255.;
	
#ifdef weather	
	lmtexcoord.zw = lmcoord*lmcoord;	
#else
#ifdef water
	lmtexcoord.xy = (gl_MultiTexCoord0).xy;	
#else	
	lmtexcoord.xy = (gl_MultiTexCoord0).xy;
	lmtexcoord.zw = lmcoord;
#endif
#endif
		

	



	texcoord = (gl_MultiTexCoord0).xy;

	
#ifdef solid1
	
	vec3 position = mat3(gl_ModelViewMatrix) * vec3(gl_Vertex) + gl_ModelViewMatrix[3].xyz;
	vec3 worldpos = mat3(gbufferModelViewInverse) * position + gbufferModelViewInverse[3].xyz + cameraPosition;
	bool istopv = worldpos.y > cameraPosition.y+5.0;
	float ft = frameTimeCounter*1.3;
	if (!istopv) position.xz += vec2(3.0,1.0)+sin(ft)*sin(ft)*sin(ft)*vec2(2.1,0.6);
	position.xz -= (vec2(3.0,1.0)+sin(ft)*sin(ft)*sin(ft)*vec2(2.1,0.6))*0.5;
	gl_Position = toClipSpace3(position);	
#else	
#ifdef water	
  vec3 position = mat3(gl_ModelViewMatrix) * vec3(gl_Vertex) + gl_ModelViewMatrix[3].xyz;

  gl_Position = toClipSpace3(position);
#else  
	gl_Position = ftransform();
#endif	
#endif	


	color = gl_Color;

#ifdef water

	float mat = 0.0;
	if(mc_Entity.x == 8.0 || mc_Entity.x == 9.0) {
    mat = 1.0;
    gl_Position.z -= 1e-4;
  }


	if(mc_Entity.x == 79.0) mat = 0.5;
		if (mc_Entity.x == 10002) mat = 0.01;
	normalMat = vec4(normalize( gl_NormalMatrix*gl_Normal),mat);


								   


	tangent = normalize( gl_NormalMatrix *at_tangent.rgb);
	binormal = normalize(cross(tangent.rgb,normalMat.xyz)*at_tangent.w);

	mat3 tbnMatrix = mat3(tangent.x, binormal.x, normalMat.x,
								  tangent.y, binormal.y, normalMat.y,
						     	  tangent.z, binormal.z, normalMat.z);
								 
																				 
																		  
									   
	  

		dist = length(gl_ModelViewMatrix * gl_Vertex);
	   

	viewVector = ( gl_ModelViewMatrix * gl_Vertex).xyz;
	viewVector = normalize(tbnMatrix * viewVector);
	#endif
	
	
	#ifndef water
	#ifdef MC_NORMAL_MAP
		tangent = vec4(normalize(gl_NormalMatrix *at_tangent.rgb),at_tangent.w);
	#endif
	#endif
	#ifdef normal1
		normalMat = vec4(normalize(gl_NormalMatrix *gl_Normal),blockEntityId==10006? 1.0:1.0);	
	#else
	#ifndef water
		normalMat = vec4(normalize(gl_NormalMatrix *gl_Normal),0.0);
	#endif
	#endif


	#ifdef TAA_UPSCALING
		gl_Position.xy = gl_Position.xy * RENDER_SCALE + RENDER_SCALE * gl_Position.w - gl_Position.w;
	#endif
	#ifdef TAA
	gl_Position.xy += offsets[framemod8] * gl_Position.w*texelSize;
	#endif
}
